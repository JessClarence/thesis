@using thesis.Core.ViewModel;
@model ChroplethMapViewModel

<!-- leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
	  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
	  crossorigin="" />

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
		integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
		crossorigin=""></script>

<link rel="stylesheet" href="~/css/ChoroplethMap.css" asp-append-version="true" />

<!-- Leaflet Search Bar -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
<script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

<!-- CONTENT STARTS-->
<section id="content">


	<!-- MAIN STARTS-->
	<main class="geolocation">
		<div class="geo-filter">

			<form class="search-form">
				<div class="search">
					<i class='bx bx-search'></i>
					<input type="text" class="form-control Search-Input" placeholder="Search Location..." autocomplete="off">
					<div class="suggestions" style="display: none;">
						<!-- Suggestions will be populated here -->
					</div>
					<button class="btn btn-primary Search">Search</button>
				</div>
			</form>

			<div class="container heatmap">
				<div class="select-btn">
					<span class="btn-text">Show Heatmap of...</span>
					<span class="arrow-dwn">
						<i class='bx bx-caret-down'></i>
					</span>
				</div>

				<ul class="list-items">
					<form method="post" action="/ChoroplethMap/ActionResult">
					<li class="item" data-type="heatmap">
							@*<span class="checkbox">*@
						<input type="radio" name="selectedOption" value="Meat Sources" id="meatSources">
							@*<label for="meatSources">
						<i class='bx bx-check check-icon'></i>
						</label>*@
							@*</span>*@
						<span class="item-text">Meat Sources (Weight)</span>
					</li>
					<li class="item" data-type="heatmap">
							@*<span class="checkbox">*@
						<input type="radio" name="selectedOption" value="Meat Distribution" id="meatDistribution">
							@*<label for="meatDistribution">
						<i class='bx bx-check check-icon'></i>
						</label>*@
							@*</span>*@
						<span class="item-text">Meat Distribution (Weight)</span>
					</li>
					<button type="submit" class="btn btn-primary">Apply</button>
					</form>
				</ul>

			</div>

			<div class="container species">
				<div class="select-btn">
					<span class="btn-text">Select Species</span>
					<span class="arrow-dwn">
						<i class='bx bx-caret-down'></i>
					</span>
				</div>

				<ul class="list-items">
					<li class="item" data-type="species">
						<span class="checkbox">
							<i class='bx bx-check check-icon'></i>
						</span>
						<span class="item-text">Swine</span>
					</li>
					<li class="item" data-type="species">
						<span class="checkbox">
							<i class='bx bx-check check-icon'></i>
						</span>
						<span class="item-text">Chicken</span>
					</li>
					<li class="item" data-type="species">
						<span class="checkbox">
							<i class='bx bx-check check-icon'></i>
						</span>
						<span class="item-text">Cattle</span>
					</li>
					<li class="item" data-type="species">
						<span class="checkbox">
							<i class='bx bx-check check-icon'></i>
						</span>
						<span class="item-text">And So on...</span>
					</li>
					<button type="button" class="btn btn-primary">Apply</button>
				</ul>
			</div>


		</div>


		<div id="map"></div>
	</main>
	<!-- MAIN ENDS -->

</section>
<!-- CONTENT ENDS-->



<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js" asp-append-version="true"></script>
<!-- Own JS File -->
<script src="~/js/ChoroplethMap.js" asp-append-version="true"></script>

<script>
	// Initial map setup
	const map = L.map('map', {
		zoomControl: false
	}).setView([7.3042, 125.6853], 9);
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);


	const municipalityData = [
	@for (int i = 0; i < Model.Address.Count; i++)
	{
		var parts = Model.Address[i].Split(new[] { ", " }, StringSplitOptions.None);
		string desiredAddress = (parts.Length >= 3) ? string.Join(", ", parts[1], parts[2]) : "Invalid Address";
		@:{ name: "@desiredAddress", specie: "Cattle", value: @Model.Cattle[i] },
		@:{ name: "@desiredAddress", specie: "Carabao", value: @Model.Carabao[i] },
		@:{ name: "@desiredAddress", specie: "Swine", value: @Model.Swine[i] },
		@:{ name: "@desiredAddress", specie: "Goat", value: @Model.Goat[i] },
		@:{ name: "@desiredAddress", specie: "Chicken", value: @Model.Chicken[i] },
		@:{ name: "@desiredAddress", specie: "Duck", value: @Model.Duck[i] },
		@:{ name: "@desiredAddress", specie: "Sheep", value: @Model.Sheep[i] },
		@:{ name: "@desiredAddress", specie: "Horse", value: @Model.Horse[i] },
		@:{ name: "@desiredAddress", specie: "Ostrich", value: @Model.Ostrich[i] },
		@:{ name: "@desiredAddress", specie: "Crocodile", value: @Model.Crocodile[i] },
	}
		];

	// Aggregating total value per location
	const locationTotals = municipalityData.reduce((acc, curr) => {
		const existing = acc.find(item => item.name === curr.name);
		if (existing) {
			existing.value += curr.value;
		} else {
			acc.push({ name: curr.name, value: curr.value });
		}
		return acc;
	}, []);

	// Getting max value from the aggregated totals
	const maxValue = Math.max(...locationTotals.map(item => item.value));

	function truncateMaxValue(num) {
		const length = num.toString().length;
		const divisor = Math.pow(10, length - 1);
		return Math.floor(num / divisor) * divisor;
	}

	function getColor(value, maxValue) {
		const truncatedMax = truncateMaxValue(maxValue);
		const getThreshold = (percentage) => {
			return Math.floor(truncatedMax * (percentage / 100));
		};

		if (value > getThreshold(100)) return '#800026';
		if (value > getThreshold(85)) return '#BD0026';
		if (value > getThreshold(70)) return '#E31A1C';
		if (value > getThreshold(50)) return '#FC4E2A';
		if (value > getThreshold(30)) return '#FD8D3C';
		if (value > getThreshold(15)) return '#FEB24C';
		if (value > getThreshold(5)) return '#FED976';
		if (value === 0) return 'transparent'; // No color for zero
		if (value === undefined) return 'transparent'; // No color for undefined
		return '#FFEDA0';
	}

	function styleFeature(feature) {
		return {
			fillColor: getColor(feature.properties.value, maxValue),
			weight: 2,
			opacity: 1,
			color: 'white',
			dashArray: '3',
			fillOpacity: 0.7
		};
	}

	function highlightFeature(e) {
		const layer = e.target;
		layer.setStyle({
			weight: 5,
			color: '#666',
			dashArray: '',
			fillOpacity: 0.7
		});
		layer.openTooltip();
	}

	function resetHighlight(e) {
		const layer = e.target;
		geojsonLayer.resetStyle(layer);
		layer.closeTooltip();
	}

	function mergeDataWithGeoJSON(geoJSON, data) {
		geoJSON.features.forEach(feature => {
			const dataItems = data.filter(item => item.name.toUpperCase() === feature.properties.NAME_1.toUpperCase() + ", " + feature.properties.NAME_2.toUpperCase());
			if (dataItems.length > 0) {
				feature.properties.value = dataItems.reduce((sum, item) => sum + item.value, 0);
				feature.properties.speciesData = dataItems;
			}
		});
	}

	function onEachFeature(feature, layer) {
		layer.on({
			mouseover: highlightFeature,
			mouseout: resetHighlight
		});

		let tooltipContent = `<strong>${feature.properties.NAME_1}, ${feature.properties.NAME_2}</strong><br/>Total Meat Qty: ${feature.properties.value !== undefined ? feature.properties.value : 0} Kilograms<br/>`;

		if (feature.properties.speciesData) {
			feature.properties.speciesData.forEach(item => {
				tooltipContent += `${item.specie}: ${item.value} Kilograms<br/>`;
			});
		}

		layer.bindTooltip(tooltipContent, {
			permanent: false,
			interactive: false
		});
	}


	// Fetch data and render on map
	fetch('https://raw.githubusercontent.com/Adrianne1001/Geojson-and-address-JSON/main/philippines_municipalities.geojson')
		.then(response => response.json())
		.then(topojsonData => {
			const geoJSON = topojson.feature(topojsonData, topojsonData.objects.PHL_adm2);
			mergeDataWithGeoJSON(geoJSON, municipalityData);

			let maxValue = Math.max(...municipalityData.map(d => d.value));
			maxValue = truncateMaxValue(maxValue);

			geojsonLayer = L.geoJson(geoJSON, {
				style: feature => styleFeature(feature, maxValue),
				onEachFeature: onEachFeature
			}).addTo(map);

			const legend = L.control({ position: 'bottomleft' });
			legend.onAdd = function (map) {
				var div = L.DomUtil.create('div', 'info legend');
				const percentages = [0, 5, 15, 30, 50, 70, 85, 100];
				const grades = percentages.map(p => Math.floor(maxValue * (p / 100)));

				for (let i = 0; i < grades.length; i++) {
					div.innerHTML +=
						`<i style="background:${getColor(grades[i] + 1, maxValue)}"></i> ` +
						`${Math.max(1, grades[i])}${grades[i + 1] ? `&ndash;${grades[i + 1]}<br>` : '+'}`;
				}

				return div;
			};
			legend.addTo(map);

		});
</script>

